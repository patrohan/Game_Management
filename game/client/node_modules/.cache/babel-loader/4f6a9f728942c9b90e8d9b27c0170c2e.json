{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uServer = void 0;\n\nconst debug_1 = require(\"debug\");\n\nconst server_1 = require(\"./server\");\n\nconst transports_uws_1 = require(\"./transports-uws\");\n\nconst debug = (0, debug_1.default)(\"engine:uws\");\n\nclass uServer extends server_1.BaseServer {\n  init() {}\n\n  cleanup() {}\n  /**\n   * Prepares a request by processing the query string.\n   *\n   * @api private\n   */\n\n\n  prepare(req, res) {\n    req.method = req.getMethod().toUpperCase();\n    const params = new URLSearchParams(req.getQuery());\n    req._query = Object.fromEntries(params.entries());\n    req.headers = {};\n    req.forEach((key, value) => {\n      req.headers[key] = value;\n    });\n    req.connection = {\n      remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()\n    };\n  }\n\n  createTransport(transportName, req) {\n    return new transports_uws_1.default[transportName](req);\n  }\n  /**\n   * Attach the engine to a ÂµWebSockets.js server\n   * @param app\n   * @param options\n   */\n\n\n  attach(app\n  /* : TemplatedApp */\n  ) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const path = (options.path || \"/engine.io\").replace(/\\/$/, \"\") + \"/\";\n    app.any(path, this.handleRequest.bind(this)) //\n    .ws(path, {\n      maxPayloadLength: this.opts.maxHttpBufferSize,\n      upgrade: this.handleUpgrade.bind(this),\n      open: ws => {\n        ws.transport.socket = ws;\n        ws.transport.writable = true;\n        ws.transport.emit(\"drain\");\n      },\n      message: (ws, message, isBinary) => {\n        ws.transport.onData(isBinary ? message : Buffer.from(message).toString());\n      },\n      close: (ws, code, message) => {\n        ws.transport.onClose(code, message);\n      }\n    });\n  }\n\n  handleRequest(res, req) {\n    debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\n    this.prepare(req, res);\n    req.res = res;\n\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: server_1.Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        this.abortRequest(req.res, errorCode, errorContext);\n        return;\n      }\n\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext);\n\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n\n    if (this.corsMiddleware) {\n      // needed to buffer headers until the status is computed\n      req.res = new ResponseWrapper(res);\n      this.corsMiddleware.call(null, req, req.res, () => {\n        this.verify(req, false, callback);\n      });\n    } else {\n      this.verify(req, false, callback);\n    }\n  }\n\n  handleUpgrade(res, req, context) {\n    debug(\"on upgrade\");\n    this.prepare(req, res); // @ts-ignore\n\n    req.res = res;\n    this.verify(req, true, async (errorCode, errorContext) => {\n      if (errorCode) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: server_1.Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        this.abortRequest(res, errorCode, errorContext);\n        return;\n      }\n\n      const id = req._query.sid;\n      let transport;\n\n      if (id) {\n        const client = this.clients[id];\n\n        if (!client) {\n          debug(\"upgrade attempt for closed client\");\n          res.close();\n        } else if (client.upgrading) {\n          debug(\"transport has already been trying to upgrade\");\n          res.close();\n        } else if (client.upgraded) {\n          debug(\"transport had already been upgraded\");\n          res.close();\n        } else {\n          debug(\"upgrading existing transport\");\n          transport = this.createTransport(req._query.transport, req);\n          client.maybeUpgrade(transport);\n        }\n      } else {\n        transport = await this.handshake(req._query.transport, req, (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext));\n\n        if (!transport) {\n          return;\n        }\n      }\n\n      res.upgrade({\n        transport\n      }, req.getHeader(\"sec-websocket-key\"), req.getHeader(\"sec-websocket-protocol\"), req.getHeader(\"sec-websocket-extensions\"), context);\n    });\n  }\n\n  abortRequest(res, errorCode, errorContext) {\n    const statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? \"403 Forbidden\" : \"400 Bad Request\";\n    const message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];\n    res.writeStatus(statusCode);\n    res.writeHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify({\n      code: errorCode,\n      message\n    }));\n  }\n\n}\n\nexports.uServer = uServer;\n\nclass ResponseWrapper {\n  constructor(res) {\n    this.res = res;\n    this.statusWritten = false;\n    this.headers = [];\n  }\n\n  set statusCode(status) {\n    this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\n  }\n\n  setHeader(key, value) {\n    this.writeHeader(key, value);\n  } // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\n\n\n  getHeader() {}\n\n  writeStatus(status) {\n    this.res.writeStatus(status);\n    this.statusWritten = true;\n    this.writeBufferedHeaders();\n  }\n\n  writeHeader(key, value) {\n    if (key === \"Content-Length\") {\n      // the content length is automatically added by uWebSockets.js\n      return;\n    }\n\n    if (this.statusWritten) {\n      this.res.writeHeader(key, value);\n    } else {\n      this.headers.push([key, value]);\n    }\n  }\n\n  writeBufferedHeaders() {\n    this.headers.forEach(_ref => {\n      let [key, value] = _ref;\n      this.res.writeHeader(key, value);\n    });\n  }\n\n  end(data) {\n    if (!this.statusWritten) {\n      // status will be inferred as \"200 OK\"\n      this.writeBufferedHeaders();\n    }\n\n    this.res.end(data);\n  }\n\n  onAborted(fn) {\n    this.res.onAborted(fn);\n  }\n\n}","map":{"version":3,"sources":["/Users/pat/Documents/Web_development/game/node_modules/engine.io/build/userver.js"],"names":["Object","defineProperty","exports","value","uServer","debug_1","require","server_1","transports_uws_1","debug","default","BaseServer","init","cleanup","prepare","req","res","method","getMethod","toUpperCase","params","URLSearchParams","getQuery","_query","fromEntries","entries","headers","forEach","key","connection","remoteAddress","Buffer","from","getRemoteAddressAsText","toString","createTransport","transportName","attach","app","options","path","replace","any","handleRequest","bind","ws","maxPayloadLength","opts","maxHttpBufferSize","upgrade","handleUpgrade","open","transport","socket","writable","emit","message","isBinary","onData","close","code","onClose","getUrl","callback","errorCode","errorContext","undefined","Server","errorMessages","context","abortRequest","sid","clients","onRequest","closeConnection","handshake","corsMiddleware","ResponseWrapper","call","verify","id","client","upgrading","upgraded","maybeUpgrade","getHeader","statusCode","errors","FORBIDDEN","writeStatus","writeHeader","end","JSON","stringify","constructor","statusWritten","status","setHeader","writeBufferedHeaders","push","data","onAborted","fn"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.uServer = void 0;\nconst debug_1 = require(\"debug\");\nconst server_1 = require(\"./server\");\nconst transports_uws_1 = require(\"./transports-uws\");\nconst debug = (0, debug_1.default)(\"engine:uws\");\nclass uServer extends server_1.BaseServer {\n    init() { }\n    cleanup() { }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @api private\n     */\n    prepare(req, res) {\n        req.method = req.getMethod().toUpperCase();\n        const params = new URLSearchParams(req.getQuery());\n        req._query = Object.fromEntries(params.entries());\n        req.headers = {};\n        req.forEach((key, value) => {\n            req.headers[key] = value;\n        });\n        req.connection = {\n            remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()\n        };\n    }\n    createTransport(transportName, req) {\n        return new transports_uws_1.default[transportName](req);\n    }\n    /**\n     * Attach the engine to a ÂµWebSockets.js server\n     * @param app\n     * @param options\n     */\n    attach(app /* : TemplatedApp */, options = {}) {\n        const path = (options.path || \"/engine.io\").replace(/\\/$/, \"\") + \"/\";\n        app\n            .any(path, this.handleRequest.bind(this))\n            //\n            .ws(path, {\n            maxPayloadLength: this.opts.maxHttpBufferSize,\n            upgrade: this.handleUpgrade.bind(this),\n            open: ws => {\n                ws.transport.socket = ws;\n                ws.transport.writable = true;\n                ws.transport.emit(\"drain\");\n            },\n            message: (ws, message, isBinary) => {\n                ws.transport.onData(isBinary ? message : Buffer.from(message).toString());\n            },\n            close: (ws, code, message) => {\n                ws.transport.onClose(code, message);\n            }\n        });\n    }\n    handleRequest(res, req) {\n        debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\n        this.prepare(req, res);\n        req.res = res;\n        const callback = (errorCode, errorContext) => {\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                this.abortRequest(req.res, errorCode, errorContext);\n                return;\n            }\n            if (req._query.sid) {\n                debug(\"setting new request for existing client\");\n                this.clients[req._query.sid].transport.onRequest(req);\n            }\n            else {\n                const closeConnection = (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext);\n                this.handshake(req._query.transport, req, closeConnection);\n            }\n        };\n        if (this.corsMiddleware) {\n            // needed to buffer headers until the status is computed\n            req.res = new ResponseWrapper(res);\n            this.corsMiddleware.call(null, req, req.res, () => {\n                this.verify(req, false, callback);\n            });\n        }\n        else {\n            this.verify(req, false, callback);\n        }\n    }\n    handleUpgrade(res, req, context) {\n        debug(\"on upgrade\");\n        this.prepare(req, res);\n        // @ts-ignore\n        req.res = res;\n        this.verify(req, true, async (errorCode, errorContext) => {\n            if (errorCode) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                this.abortRequest(res, errorCode, errorContext);\n                return;\n            }\n            const id = req._query.sid;\n            let transport;\n            if (id) {\n                const client = this.clients[id];\n                if (!client) {\n                    debug(\"upgrade attempt for closed client\");\n                    res.close();\n                }\n                else if (client.upgrading) {\n                    debug(\"transport has already been trying to upgrade\");\n                    res.close();\n                }\n                else if (client.upgraded) {\n                    debug(\"transport had already been upgraded\");\n                    res.close();\n                }\n                else {\n                    debug(\"upgrading existing transport\");\n                    transport = this.createTransport(req._query.transport, req);\n                    client.maybeUpgrade(transport);\n                }\n            }\n            else {\n                transport = await this.handshake(req._query.transport, req, (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext));\n                if (!transport) {\n                    return;\n                }\n            }\n            res.upgrade({\n                transport\n            }, req.getHeader(\"sec-websocket-key\"), req.getHeader(\"sec-websocket-protocol\"), req.getHeader(\"sec-websocket-extensions\"), context);\n        });\n    }\n    abortRequest(res, errorCode, errorContext) {\n        const statusCode = errorCode === server_1.Server.errors.FORBIDDEN\n            ? \"403 Forbidden\"\n            : \"400 Bad Request\";\n        const message = errorContext && errorContext.message\n            ? errorContext.message\n            : server_1.Server.errorMessages[errorCode];\n        res.writeStatus(statusCode);\n        res.writeHeader(\"Content-Type\", \"application/json\");\n        res.end(JSON.stringify({\n            code: errorCode,\n            message\n        }));\n    }\n}\nexports.uServer = uServer;\nclass ResponseWrapper {\n    constructor(res) {\n        this.res = res;\n        this.statusWritten = false;\n        this.headers = [];\n    }\n    set statusCode(status) {\n        this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\n    }\n    setHeader(key, value) {\n        this.writeHeader(key, value);\n    }\n    // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\n    getHeader() { }\n    writeStatus(status) {\n        this.res.writeStatus(status);\n        this.statusWritten = true;\n        this.writeBufferedHeaders();\n    }\n    writeHeader(key, value) {\n        if (key === \"Content-Length\") {\n            // the content length is automatically added by uWebSockets.js\n            return;\n        }\n        if (this.statusWritten) {\n            this.res.writeHeader(key, value);\n        }\n        else {\n            this.headers.push([key, value]);\n        }\n    }\n    writeBufferedHeaders() {\n        this.headers.forEach(([key, value]) => {\n            this.res.writeHeader(key, value);\n        });\n    }\n    end(data) {\n        if (!this.statusWritten) {\n            // status will be inferred as \"200 OK\"\n            this.writeBufferedHeaders();\n        }\n        this.res.end(data);\n    }\n    onAborted(fn) {\n        this.res.onAborted(fn);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}